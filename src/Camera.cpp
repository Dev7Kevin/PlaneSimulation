/////////////////////////////////////////////////////////////////////////////
//
// Camera.cpp: 카메라 클래스 관련 소스 파일.
//
//
/////////////////////////////////////////////////////////////////////////////

//#include "../../engine/B3X.h" 
//#include "../../Engine_Ext/Engine.h"
#include "../../Engine/Ext/B3Yena_Ext.h"	//DLL 버전 엔진 필수헤더. 

#include "Unit.h"
#include "Plane.h"

#include "Camera.h"

 

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCamera::CCamera(LPDEVICE pDev)
: m_pDev(pDev),
  m_vEye(VECTOR3(0,0,0)),		
  m_vLookAt(VECTOR3(0,0,10)),
  m_vUp(VECTOR3(0,1,0))
{
  
	//원점 값 저장.
	m_vOrgEye = m_vEye;
	m_vOrgLookAt = m_vLookAt;
	m_vOrgUp = m_vUp;

	strcpy(m_Name, "기본카메라"); 
	m_FCType = FCT_NOFIX_;			//
	 
	SetLocalVectors(); 
	SetProject(D3DX_PI/4, 1.3333f, 0.1f, 100000.0f);	//기본렌즈  
 	 

	m_vOrgNView = m_vNView;	
	m_vOrgHorz = m_vHorz; 

	//빌보드 행렬 초기화.
	D3DXMatrixIdentity(&m_mInverseView);
	D3DXMatrixIdentity(&m_mBillMtx);
	
	m_fOrgFovY = m_fFovY = D3DX_PI/4;	
	m_fRatio = (float)g_B3Mode.Width/(float)g_B3Mode.Height;				
	m_fZfar = 1.0f;						
	m_fZnear = 1000.0f;						

 	 

	B3D_Error(NO_, "[OK]%s 생성됨(0x%x)", m_Name,this);
	
}


///////////////////////////////////////////////////////////////////////
//
CCamera::CCamera(
			LPDEVICE pDev, 
			char* name,
			FIXCAMERA_TYPE type,	//
			POS3 eye, 
			DIR3 view /*= VECTOR3(0, 0, 1)*/, //카메라 시선벡터.			 
			DIR3 up /*=VECTOR3(0, 1, 0)*/,
			float fovy/* = D3DX_PI/4*/, 
			float ratio/*=640.0f/480.0f*/,
			float zn/* = 0.1f*/, 
			float zf/* = 100000.0f*/     
			)
: m_pDev(pDev), m_vEye(eye),
  //m_vLookAt(eye+lookat*10.0f), 
  m_vUp(up)
{

	//방향벡터계산..
	D3DXVec3Normalize(&m_vNView, &view);
	D3DXVec3Normalize(&m_vUp, &up);
	D3DXVec3Cross(&m_vHorz, &m_vUp, &m_vNView);


	//원점 값 저장.
	m_vOrgEye = m_vEye;
	m_vOrgLookAt = m_vLookAt = m_vEye +  m_vNView * 10.0f;
	m_vOrgUp = m_vUp;
 
	strcpy(m_Name, name);
	m_FCType = type;			//

   	SetProject(fovy, ratio, zn, zf);		//렌즈 결정 
 

	m_vOrgNView = m_vNView;	
	m_vOrgHorz = m_vHorz; 

	//빌보드 행렬 초기화.
	D3DXMatrixIdentity(&m_mInverseView);
	D3DXMatrixIdentity(&m_mBillMtx);

	m_fOrgFovY = m_fFovY = fovy;	
	m_fRatio = ratio;				
	m_fZfar = zf;					
	m_fZnear = zn;						

	
	B3D_Error(NO_, "[OK]%s 생성됨(0x%x)", m_Name, this);

}




///////////////////////////////////////////////////////////////////////
//
CCamera::~CCamera()
{
	//N/A	

	B3D_Error(NO_, "[OK]%s 제거됨 (0x%x)", m_Name, this);

}



 


///////////////////////////////////////////////////////////////////////
//
void CCamera::Reset()
{
	m_vEye = m_vOrgEye;
	m_vLookAt = m_vOrgLookAt;
	m_vUp = m_vOrgUp;
	
	SetLocalVectors(); 
 

	m_vOrgNView = m_vNView;	
	m_vOrgHorz = m_vHorz; 

	//빌보드 행렬 초기화.
	D3DXMatrixIdentity(&m_mInverseView);
	D3DXMatrixIdentity(&m_mBillMtx);

	m_fFovY = m_fOrgFovY;  

}




///////////////////////////////////////////////////////////////////////
//
// 카메라의 로컬 회전 및 이동을 위한 방향벡터 계산.
//
void CCamera::SetLocalVectors()
{
	//시선벡터 계산.
	D3DXVec3Normalize(&m_vNView, &(m_vLookAt - m_vEye));

	//시선 벡터로 부터 외적을 통해 '수평' 벡터 계산.
	D3DXVec3Cross(&m_vHorz, &m_vUp, &m_vNView);
	//D3DXVec3Normalize(&m_vHorz, &m_vHorz);

	//수평과 시선 벡터로 부터 '수직 벡터 계산'
	D3DXVec3Cross(&m_vUp, &m_vNView, &m_vHorz);
	//D3DXVec3Normalize(&m_vUp, &m_vUp);
}



///////////////////////////////////////////////////////////////////////
//
// 카메라 렌즈 교환 시키기 
//
// 엔진의 기본 렌즈 말고 '원하는 스타일'의 
// 렌즈를 장착하는 것도 가능. - 옵션. 나중에 업데이트 할 것있습니다..
//
void CCamera::SetProject(
				float fovy/* = D3DX_PI/4*/,
				float ratio/*=640.0f/480.0f*/,
				float Zn/* = 0.1f*/, 
				float Zf/* = 100000.0f*/
				)
{
	D3DXMatrixPerspectiveFovLH(&m_mProj, fovy, ratio, Zn, Zf);
	m_pDev->SetTransform(D3DTS_PROJECTION, &m_mProj);

	m_fFovY = m_fOrgFovY = fovy;	
	m_fRatio = ratio;				
	m_fZfar = Zf;					
	m_fZnear = Zn;						

}


/*
void CCamera::SetProject()
{ 	//D3DXMatrixPerspectiveFovLH(&m_mProj, fovy, ratio, Zn, Zf);
	m_pDev->SetTransform(D3DTS_PROJECTION, &m_mProj);
}
*/



///////////////////////////////////////////////////////////////////////
//
// 카메라 정보를 Dev 에 설정합니다. 
//
void CCamera::SetView(LPDEVICE pDev/*=NULL*/)
{
 	// 카메라 행렬 계산.
 	D3DXMatrixLookAtLH(&m_mView, &m_vEye, &m_vLookAt, &m_vUp);


 	// 빌보등을 위해 역행렬 구합니다.
 	_MakeInverseMtx();  


	if(pDev == NULL)		//pDev 가 NULL 이면 내부 장치로 사용.
		pDev = m_pDev;
	pDev->SetTransform(D3DTS_VIEW, &m_mView);
	pDev->SetTransform(D3DTS_PROJECTION, &m_mProj);		//렌즈설정 
	
}







///////////////////////////////////////////////////////////////////////
//
// _MakeInverseMtx : 카메라의 역행렬 및 빌보드 행렬을 계산합니다.
//
void CCamera::_MakeInverseMtx()
{
	//카메라의 역행렬구하기.
	D3DXMatrixInverse(&m_mInverseView, NULL, &m_mView);

	//빌보드 '회전 행렬' : '이동값'은 무시합니다.
	m_mBillMtx = m_mInverseView;
	m_mBillMtx._41 = 0.0f;
	m_mBillMtx._42 = 0.0f;
	m_mBillMtx._43 = 0.0f;

}



 

///////////////////////////////////////////////////////////////////////
//
// World 공간을 기준으로 카메라 이동하기.
//
void CCamera::WMove(VECTOR3 mov)
{
 	m_vEye += mov;
	m_vLookAt += mov;
	 
 	//SetView();	
}


 




/////////////////////////////////////////////////////////////////////////////
//
// 카메라 공간 : X 축 회전하기.
//
void CCamera::LRotateX(float angle)
{
	if(fabs(angle) <= 0.0001f) return;

 	//카메라 공간에서 회전하기.
	MATRIX mRot;
	D3DXMatrixRotationAxis(&mRot, &m_vHorz, angle);		

	//'회전값'을 월드 공간으로 변환, '시선 벡터'의 뱡향을 다시 계산합니다.
	D3DXVec3TransformNormal(&m_vNView, &m_vNView, &mRot);

	//'수직 벡터' 재 계산.
	D3DXVec3Cross(&m_vUp, &m_vNView, &m_vHorz);
	//D3DXVec3Normalize(&m_vUp, &m_vUp);

	//3. '수평 벡터' 재 계산. -> 필요 없음. 


	//최종 시선점 계산.
	m_vLookAt  = m_vEye + m_vNView*10.0f; 

	//SetView();
}






/////////////////////////////////////////////////////////////////////////////
//
// 카메라 공간 : Y 축 회전하기.
//
void CCamera::LRotateY(float angle)
{
	if(fabs(angle) <= 0.0001f) return;

	MATRIX mRot;
	D3DXMatrixRotationAxis(&mRot, &m_vUp, angle);		//카메라 공간에서 회전하기.

	//'회전값'을 월드 공간으로 변환, '시선 벡터'의 뱡향을 다시 계산합니다.
	D3DXVec3TransformNormal(&m_vNView, &m_vNView, &mRot);

	// 수직 벡터 계산 -> 필요 없음. 

	//'수평 벡터' 재 계산.  
	D3DXVec3Cross(&m_vHorz, &m_vUp, &m_vNView);
	//D3DXVec3Normalize(&m_vHorz, &m_vHorz);

	//최종 시선점 계산.
	m_vLookAt  = m_vEye + m_vNView * 10.0f; 

	
	//SetView();
}





/////////////////////////////////////////////////////////////////////////////
//
// 카메라 공간 : Z 축 회전하기.
//
void CCamera::LRotateZ(float angle)
{
	if(fabs(angle) <= 0.0001f) return;

	MATRIX mRot;
	D3DXMatrixRotationAxis(&mRot, &m_vNView, angle);		//카메라 공간에서 회전하기.

	//1. '시선 벡터'의 뱡향을 다시 계산합니다. : 필요 없음.


	//2. 회전된 '수직'벡터 계산.
	D3DXVec3TransformNormal(&m_vUp, &m_vUp, &mRot);
 	

	//3.'수평 벡터' 재 계산.  
	D3DXVec3Cross(&m_vHorz, &m_vUp, &m_vNView);
	//D3DXVec3Normalize(&m_vHorz, &m_vHorz);
 
	//4.  최종 시선점 계산. : 시점이 이동되지 않았음. 

	//SetView();
}







//////////////////////////////////////////////////////////////////////////////
//
// 카메라의 X 축 : '수평벡터' 를 기준으로 mov 만큼 이동합니다.
//
void CCamera::LMoveX(float mov)
{
	//1. 수평 벡터를 단위펙터로 환산합니다. (계산의 편리를 위해..)
	VECTOR3 vTemp;
	D3DXVec3Normalize(&vTemp, &m_vHorz);


	//2. 이동량 = 계산된 단위벡터 * mov : '벡터가 커진다' -> 이동한 '위치' 가 됩니다..
	vTemp = vTemp * mov;

	//3. 계산된 이동량 만큼 카메라의 위치/시점을 이동.
	m_vEye += vTemp;
	m_vLookAt += vTemp;


	//4. 카메라 행렬 새 설정.
	//SetView();
}



//////////////////////////////////////////////////////////////////////////////
//
// 카메라의 Y 축 : 카메라 '수직벡터' 를 기준으로 mov 만큼 이동합니다.
//
void CCamera::LMoveY(float mov)
{
	//1. 수직 벡터를 단위펙터로 환산합니다. (계산의 편리를 위해..)
	VECTOR3 vTemp;
	D3DXVec3Normalize(&vTemp, &m_vUp);


	//2. 이동량 = 계산된 단위벡터 * mov : '벡터가 커진다' -> 이동한 '위치' 가 됩니다..
	vTemp = vTemp * mov;

	//3. 계산된 이동량 만큼 카메라의 위치/시점을 이동.
	m_vEye += vTemp;
	m_vLookAt += vTemp;


	//4. 카메라 행렬 새 설정.
	//SetView();
}



//////////////////////////////////////////////////////////////////////////////
//
//  카메라의 Z 축 : '시선 벡터' 를 기준으로 mov 만큼 이동합니다.
//
void CCamera::LMoveZ(float mov)
{
	//1. 시선 벡터를 단위펙터로 환산합니다. (계산의 편리를 위해..)
	VECTOR3 vTemp;
	D3DXVec3Normalize(&vTemp, &m_vNView);


	//2. 이동량 = 계산된 단위벡터 * mov : '벡터가 커진다' -> 이동한 '위치' 가 됩니다..
	vTemp = vTemp * mov;

	//3. 계산된 이동량 만큼 카메라의 위치/시점을 이동.
	m_vEye += vTemp;
	m_vLookAt += vTemp;


	//4. 카메라 행렬 새 설정.
	//SetView();
}










//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// 
// 
// 
// class CCamFree : 자유카메라
// 
// 
// 
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
CCamFree::CCamFree(
				   LPDEVICE pDev, 
				   char* name,
				   FIXCAMERA_TYPE type,	//
				   POS3 eye, 
				   DIR3 view/*= VECTOR3(0, 0, 1)*/, 
				   //VECTOR3 lookat/*= VECTOR3(0, 0, 0)*/, 
				   DIR3 up/*== VECTOR3(0, 1, 0)*/,
				   float fovy/* = D3DX_PI/4*/, 
				   float ratio/*=640.0f/480.0f*/,
				   float zn/* = 0.1f*/, 
				   float zf/* = 100000.0f*/     
				   )
:CCamera( pDev, name, type, //
		 eye, view, up, fovy, ratio, zn, zf)
{
	//...
}



//////////////////////////////////////////////////////////////////////////////
//
CCamFree::~CCamFree()
{
	//...
}



//////////////////////////////////////////////////////////////////////////////
//
int CCamFree::Update(float dTime/*= 0*/)
{
	
	// 공간에서 자유로이 움직있습니다....
	static float mov = 0.0f;
/*
	//
	// 카메라 월드 이동 처리.
	//
	static float mov = 0.0f;
	mov = dTime * 5.0f;					//이동 속도 결정.

	if(IsKeyDown(DIK_I))							//+Z
		_pCurrCam->WMove(VECTOR3(0, 0, mov));
	if(IsKeyDown(DIK_K))							//-Z
		_pCurrCam->WMove(VECTOR3(0, 0, -mov));
	if(IsKeyDown(DIK_J))							//-X
		_pCurrCam->WMove(VECTOR3(-mov, 0, 0));
	if(IsKeyDown(DIK_L))							//+X
		_pCurrCam->WMove(VECTOR3( mov, 0, 0));
	if(IsKeyDown(DIK_P))							//+Y
		_pCurrCam->WMove(VECTOR3( 0, mov, 0));
	if(IsKeyDown(DIK_SEMICOLON))					//-Y
		_pCurrCam->WMove(VECTOR3( 0, -mov, 0));

*/

	//
	// 카메라 로컬 회전	
	//
	// 마우스 기준 회전.
 	//mov = dTime * 5.0f;
	LONG x, y, z;
	float fac = 0.003f;		//감도.
	B3Input_GetMouseRelativePt(&x, &y, &z);
	LRotateY(x * fac);
	LRotateX(y * fac);	

	//Y 축은 고정 : '눈' 편하다.;;
	m_vUp = VECTOR3(0, 1, 0);
	
/*	//키보드 기준 회전.
	mov = dTime * D3DX_PI; 
	if(IsKeyDown(DIK_DELETE))		//-Y
		LRotateY(-mov);  
	if(IsKeyDown(DIK_PGDN))			//+Y
		LRotateY(mov); 
	if(IsKeyDown(DIK_HOME))			//+X
		LRotateX(mov);
	if(IsKeyDown(DIK_END))			//-X
		LRotateX(-mov);
	if(IsKeyDown(DIK_INSERT))		//+Z
		LRotateZ(mov);
	if(IsKeyDown(DIK_PGUP))			//-Z
		LRotateZ(-mov);
*/

	//
	// 카메라 로컬 이동 처리.
	//
	mov = dTime * 10.0f;					//이동 속도 결정.

	if(IsKeyDown(DIK_R))			//+Y
		LMoveY( mov);
	if(IsKeyDown(DIK_F))			//-Y
		LMoveY(-mov);
	if(IsKeyDown(DIK_A))			//-X
		LMoveX(-mov);
	if(IsKeyDown(DIK_D))			//+X
		LMoveX( mov);
	if(IsKeyDown(DIK_W))			//+Z
		LMoveZ( mov);
	if(IsKeyDown(DIK_S))			//-Z
		LMoveZ(-mov);


	//해상도 변경시, 렌즈 변경.추후 갱신 예정.
	SetProject( m_fFovY, (float)g_Mode.Width/g_Mode.Height); 
	SetView();


	return 1;
}






//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// 
// 
// 
// class CCamModelFix  : 모델 고정 카메라
// 
// 
// 
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
CCamModelFix::CCamModelFix(
				   LPDEVICE pDev, 
				   char* name,
				   FIXCAMERA_TYPE type,	//
				   const CUnit* pUnit,
				   POS3 eye,						//모델공간의 로컬좌표기준임.주의.
				   DIR3 view,						//모델공간에서의 시선벡터.  
				   DIR3 up /*= VECTOR3(0, 1, 0)*/,
				   float fovy/* = D3DX_PI/4*/, 
				   float ratio/*=640.0f/480.0f*/,
				   float zn/* = 0.1f*/, 
				   float zf/* = 100000.0f*/     
				   )
:CCamera( pDev, name, type, //
		 eye, view, up, fovy, ratio, zn, zf)
{
	//...
	m_pUnit = const_cast<CUnit*>(pUnit);
}



//////////////////////////////////////////////////////////////////////////////
//
CCamModelFix::~CCamModelFix()
{
	//...
}





/////////////////////////////////////////////////////////////////////////////
//
void CCamModelFix::Reset()
{
	CCamera::Reset();
 
	//추가 리셋코드를 여기에..
}






/////////////////////////////////////////////////////////////////////////////
//
//  void SetFixPosition(..)
//
//  카메라의 성분을  Unit 의 모델공간상의 상대좌표로 설정합니다.
//  이후 Tracking 을 통해 벡터들을 갱신합니다.
//
void CCamModelFix::SetFixPosition(
								  POS3 eye,			 //'유닛' 모델공간에서의 카메라 상대 위치 벡터.(불변)
								  DIR3 view,
								  DIR3 up,
								  const CUnit* pUnit	 //목표 포인터.  
								  )
{

	//방향벡터계산..
	D3DXVec3Normalize(&m_vNView, &view);
	D3DXVec3Normalize(&m_vUp, &up);
	D3DXVec3Cross(&m_vHorz, &m_vUp, &m_vNView);


	//'유닛' 모델공간에서의 카메라 벡터 갱신. 
	//
 	m_vEye = eye;					
 	m_vLookAt = eye +  m_vNView * 10.0f; 
	//m_vUp = up; 

	//목표 설정.
	m_pUnit = const_cast<CUnit*>(pUnit);	


	//---------------------------------------------------------------------
	// 원점 값 저장.
	//---------------------------------------------------------------------
	// m_vEye 는 '월드 공간'에서의 카메라 좌표이므로 유닛을 추적하기위해서는 
	// 상대값- 초기값 -을 저장한 m_vOrgEye 를 사용할 것이다. 
	//
	m_vOrgEye = m_vEye;
	m_vOrgLookAt = m_vLookAt;
	m_vOrgUp = m_vUp;


	//---------------------------------------------------------------------
	// 카메라 행렬 계산.
	//---------------------------------------------------------------------
	//SetLocalVectors();		//수평/시선벡터 생성.
	//SetView();			//View 행렬 생성.


}
 



//////////////////////////////////////////////////////////////////////////////
//
// '모델공간'에서 카메라를 위치시켜 모델과 합니다께 '회전' 처리됩니다.. 
//
void CCamModelFix::Tracking(const CUnit* pUnit/*=NULL*/)
{
	// 비행기 '변환 행렬' 구하기.	  
	if(pUnit) m_pUnit = const_cast<CUnit*>(pUnit);
	MATRIX mRot = m_pUnit->GetRotMtx(); 
	MATRIX mTM = m_pUnit->GetTM();


	// 카메라의 성분 설정 => 비행기와의  상대 좌표 : '비행기 모델공간' 좌표
	// 비행기의 TM 을 통해  카메라 성분의 월드 '이동 성분'을 얻는다.
	D3DXVec3TransformCoord(&m_vEye, &m_vOrgEye, &mTM);		 
	D3DXVec3TransformCoord(&m_vLookAt, &m_vOrgLookAt, &mTM);	 


	// 비행기의 '로컬 회전 행렬' 에서 카메라의 '회전 성분'을 얻는다. 
	// => vUp 하나면 충분하다.
	D3DXVec3TransformNormal(&m_vUp, &m_vOrgUp, &mRot);
	//D3DXVec3Normalize(&m_vUp, &m_vUp); 


	// 카메라의 나머지 축벡터를 계산합니다.
	SetLocalVectors();  
	//SetView();				//View 행렬 설정.		
}







//////////////////////////////////////////////////////////////////////////////
//
int CCamModelFix::Update(float dTime/*= 0*/)
{	
	
	Tracking();		//추적....


	//해상도 변경시, 렌즈 변경.추후 갱신 예정.
	SetProject( m_fFovY, (float)g_Mode.Width/g_Mode.Height); 
	//SetProject( D3DXToRadian(120), (float)g_Mode.Width/g_Mode.Height); 
	SetView();


	return 1;
}






//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// 
// 
// 
// class CCamTracking  : 월드 고정 + 모델 주시 카메라.
// 
// 
// 
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
CCamTracking::CCamTracking(
						   LPDEVICE pDev,
						   char* name,
						   FIXCAMERA_TYPE type,	//
						   const CUnit* pUnit,
						   POS3 eye, 						    
						   DIR3 up/*=VECTOR3(0, 1, 0)*/,
						   float fovy/* = D3DX_PI/4*/, 
						   float ratio/*=640.0f/480.0f*/,
						   float zn/* = 0.1f*/, 
						   float zf/* = 100000.0f*/     
						   )
:CCamera( pDev, name, type,  //
		  eye,  
		 //추적카메라의 기본 시선위치는 POS3(0,0,0)을 바라보도록 하기위해
		 //위치정보를 시선벡터로 사용.
		 (DIR3)-eye, 
		  
		  up, fovy, ratio, zn, zf)
{
	//...
	m_pUnit = const_cast<CUnit*>(pUnit);
}



//////////////////////////////////////////////////////////////////////////////
//
CCamTracking::~CCamTracking()
{
	//...
}


 


//////////////////////////////////////////////////////////////////////////////
//
int CCamTracking::Update(float dTime/*= 0*/)
{ 		
	//유닛 주시..
	m_vLookAt = m_pUnit->GetPos();

	//벡터 계산.
	SetLocalVectors();
	m_vUp = m_vOrgUp;		//원본 상방은 원본(0, 1, 0) 으로 유지합니다. 
	

	//해상도 변경시, 렌즈 변경.추후 갱신 예정.
	SetProject( m_fFovY, (float)g_Mode.Width/g_Mode.Height); 
	SetView();
 	 

	
	return 1;
}










//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// 
// 
// 
// class CCamPilot  : 파일럿 카메라 : 위치고정(캇핏) + 시점 제한 카메라. 
// 
// 
// 
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
CCamPilot::CCamPilot(
						   LPDEVICE pDev,
						   char* name,
						   FIXCAMERA_TYPE type,	//
						   const CUnit* pUnit,
						   VECTOR3 vRotLimit,					//회전 최대값.
						   //float angleLimit,					//회전각 제한 최대값.
						   POS3 eye, 
						   DIR3 view/*=VECTOR3(0, 0, -1)*/, 
						   DIR3 up/*=VECTOR3(0, 1, 0)*/,
						   float fovy/* = D3DX_PI/4*/, 
						   float ratio/*=640.0f/480.0f*/,
						   float zn/* = 0.1f*/, 
						   float zf/* = 100000.0f*/     
						 )
:CCamModelFix( pDev, name, type, pUnit, eye, view, up, fovy, ratio, zn, zf)
{
	//...
	m_vRotLimit = vRotLimit; 
	m_vRot = VECTOR3(0,0,0);
 
}



//////////////////////////////////////////////////////////////////////////////
//
CCamPilot::~CCamPilot()
{
	//...
}







/////////////////////////////////////////////////////////////////////////////
//
void CCamPilot::Reset()
{
	CCamModelFix::Reset();

	m_vRot = VECTOR3(0,0,0);
	m_vUp = VECTOR3(0, 1, 0);  //상방은 고정. 
}



/////////////////////////////////////////////////////////////////////////////
// 
// 카메라 로컬축 회전하기.
//
void CCamPilot::LRotate(VECTOR3 vRot)
{

	//로컬 공간 기준 : 회전행렬 만들기.
	MATRIX mRotY;
	D3DXMatrixRotationAxis(&mRotY, &m_vOrgUp, vRot.x);		//마우스 x 기준. 
  	MATRIX mRotX;
	D3DXMatrixRotationAxis(&mRotX, &m_vOrgHorz, vRot.y);	//마우스 y 기준.	
 

	//로컬 벡터 계산.
	MATRIX mRot = mRotX * mRotY;
	D3DXVec3TransformNormal(&m_vNView, &m_vOrgNView, &mRot);
	D3DXVec3TransformNormal(&m_vHorz, &m_vOrgHorz, &mRot);
	m_vUp = VECTOR3(0, 1, 0);			


	//최종 시선점 계산.
	m_vEye = m_vOrgEye;
	m_vLookAt  = m_vOrgEye + m_vNView*10.0f; 
	

}

 

/////////////////////////////////////////////////////////////////////////////
//
// ZoomIO  : 카메라 줌/인아웃 처리, fovy 를 조절합니다.
//
float  CCamPilot::ZoomIO(float v)
{ 
	const static float fac = 0.003f;		//감도.
 	float vy = v * fac;

	if(fabs(vy) <= 0.01f) return m_fFovY;
 
	m_fFovY += vy; 

	if(m_fFovY > D3DXToRadian(45))  m_fFovY = D3DXToRadian(45);
	if(m_fFovY < D3DXToRadian(15))  m_fFovY = D3DXToRadian(15);

	//debug.test.
	//B3Console::Write("Fovy : %.2f, vy=%.2f v=%.2f\n", D3DXToDegree(m_fFovY), vy, v); 

	return m_fFovY;

}






//////////////////////////////////////////////////////////////////////////////
//
int CCamPilot::Update(float dTime/*= 0*/)
{  
	//미들버튼 리셋.
	if(IsMButtonUp())
	{
		//Reset(); 
		//return 1;
		return Reset(), 1;
	}

  
	// 카메라 회전량 (순간,상대량) 계산.
	//
	LONG x = 0, y = 0, z = 0;
	float fac = 0.003f;		//감도.
	B3Input_GetMouseRelativePt(&x, &y, &z);
 	
	VECTOR3 vRot((float)x, (float)y, (float)z);
 
	//누계.
	m_vRot += vRot * fac;

 
	// 제한값 체크.
	LIMIT(m_vRot.x, m_vRotLimit.x);
	LIMIT(m_vRot.y, m_vRotLimit.y);
	//LIMIT(m_vRot.z, m_vRotLimit.z);


	//모델공간 기준 회전.
	LRotate(m_vRot);
  
	//유닛의 월드 기준 회전
	D3DXVec3TransformCoord(&m_vEye, &m_vEye, &m_pUnit->GetTM());
	D3DXVec3TransformCoord(&m_vLookAt, &m_vLookAt, &m_pUnit->GetTM());
	D3DXVec3TransformNormal(&m_vUp, &m_vUp, &m_pUnit->GetRotMtx());
	D3DXVec3TransformNormal(&m_vNView, &m_vNView, &m_pUnit->GetRotMtx());
	D3DXVec3TransformNormal(&m_vHorz, &m_vHorz, &m_pUnit->GetRotMtx());
 	
	//줌인 처리.
	float fovy = ZoomIO((float)z);
 	//해상도 변경시, 렌즈 변경.추후 갱신 예정.
	SetProject( fovy, (float)g_Mode.Width/g_Mode.Height); 


	//-----------------------------------------------------------------------
	// 외부 조망 카메라들은  '카메라 위치값' 에서 '비행기의 흔들림'값을 빼준다. 
	// 카메라는 같이 '흔들리지 않으나 조종석 카메라는 비행기와 같이 흔들려야 한다.
	// (탑승한 조종사의 시야 와 동일하다.  
	// 2004.07.01.
	CPlane* pPlane = dynamic_cast<CPlane*>(m_pUnit);
	ASSERT( pPlane != NULL); 
	VECTOR3 vShake = pPlane->GetShake();
	//if((m_FCType & 0xff00 ) == FCT_OUTER_)		//외부 카메라가 이면  '흔들림' 값을 뺀다.
	//if(IsType(FCT_OUTTER_))
	//{
	//	m_vEye -= vShake; 
	//	m_vLookAt -= vShake; 
	//}
	//else										//내부 카메라는 비행기의 흔들림에 카메라 흔들림값을 조금 더한다.
	//{											//그래야, '월드'가 흔들려 보인다.
	m_vEye += vShake;
	m_vLookAt -= vShake;						//아래, 위로 흔들어 주기...ㅡㅡ;;
	//}//
	//------------------------------------------------------------------------


  	SetView();


	return 1;
}





/************* end of file "Camera.cpp" ***********************************/ 













/* 각도제한.
if(abs(m_vRot.x) > m_vRotLimit.x)
{
m_vRot.x = (m_vRot.x/m_vRot.x) * m_vRotLimit.x;
}

if(abs(m_vRot.y) > m_vRotLimit.y)
{
m_vRot.y = (m_vRot.y/m_vRot.y) * m_vRotLimit.y
}

if(abs(m_vRot.z) > m_vRotLimit.z)
{
m_vRot.z = (m_vRot.z/m_vRot.z) * m_vRotLimit.z
}
*/





 


